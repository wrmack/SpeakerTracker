//
//  DisplayEntitiesPopUpInteractor.swift
//  SpeakerTracker
//
//  Created by Warwick McNaughton on 7/09/18.
//  Copyright (c) 2018 Warwick McNaughton. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol DisplayEntitiesPopUpBusinessLogic {
   func fetchEntities(request: DisplayEntitiesPopUp.Entities.Request)
}

protocol DisplayEntitiesPopUpDataStore {
}


class DisplayEntitiesPopUpInteractor: DisplayEntitiesPopUpBusinessLogic, DisplayEntitiesPopUpDataStore {
    var presenter: DisplayEntitiesPopUpPresenter?
    var entity: Entity?
    var entities: [Entity]?
    
    
   
    func fetchEntities(request: DisplayEntitiesPopUp.Entities.Request) {
        entities = [Entity]()
        let fileManager = FileManager.default
        guard let docDirectory = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else {
            print("DisplayEntitiesPopUpInteractorInteractor: fetchEntities: error: Document directory not found")
            return
        }
        do {
            var entityUrls = [URL]()
            let fileURLs = try fileManager.contentsOfDirectory(at: docDirectory, includingPropertiesForKeys: nil)
            for url in fileURLs {
                if url.pathExtension == "ent" {
                    entityUrls.append(url)
                }
            }
            if entityUrls.count == 0 {
                let response = DisplayEntitiesPopUp.Entities.Response(entities: self.entities)
                self.presenter?.presentEntities(response: response)
            }
            
            else {
                for entityUrl in entityUrls {
                    let entityDoc = EntityDocument(fileURL: entityUrl)
                    entityDoc.open(completionHandler: { success in
                        if !success {
                            print("DisplayEntitiesInteractor: fetchEntities: error opening EntityDocument")
                        }
                        else {
                            entityDoc.close(completionHandler: { success in
                                guard let entity = entityDoc.entity else {
                                    print("DisplayEntitiesInteractor: fetchEntities: entity is nil")
                                    return
                                }
                                self.entities!.append(entity)
                                if self.entities!.count == entityUrls.count {
                                    self.entities?.sort(by: {
                                        if $0.name! < $1.name! {
                                            return true
                                        }
                                        return false
                                    })
                                    let response = DisplayEntitiesPopUp.Entities.Response(entities: self.entities)
                                    self.presenter?.presentEntities(response: response)
                                }
                            })
                        }
                    })
                }
            }
            
            
        } catch {
            print("DisplayEntitiesPopUpInteractorInteractor: error while enumerating files \(docDirectory.path): \(error.localizedDescription)")
        }
    }
    
    
    func getEntity(index: Int) -> Entity? {
        if (entities?.count)! > 0 {
            return entities![index]
        }
        return nil
    }
}
