//
//  TrackSpeakersViewController.swift
//  SpeakerTracker
//
//  Created by Warwick McNaughton on 14/09/18.
//  Copyright (c) 2018 Warwick McNaughton. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol TrackSpeakersDisplayLogic: class {
    func displayNames(viewModel: TrackSpeakers.Speakers.ViewModel)
}




class TrackSpeakersViewController: UIViewController, TrackSpeakersDisplayLogic,  UITableViewDelegate, UITableViewDataSource {
    
    var interactor: TrackSpeakersBusinessLogic?
    var router: (NSObjectProtocol & TrackSpeakersRoutingLogic & TrackSpeakersDataPassing)?

    // MARK: - Properties
    
    /// Tables are stored as an array of 3 tuples.  Each tuple contains the UITableView reference and a dictionary giving members' names in each section.
    private var tableCollection = [(UITableView, [Int : [String]]?)]()
    
    /// Stores the total list of members as presented initially in first table.  The default names are overwritten if user has saved a list to user defaults.
    private var remainingNames = [String?]()
    
    /// Tracks whether the timer is visible.
    private var timerVisible = false
    
    /// A reference to the timer.
    private var timer: Timer?
    
    /// Stores the start time when timer is started.
    private var startTime: Date?
    
    /// Tracks the pause toggle
    private var pausePressed = false
    
    /// Stores time when pause is pressed
    private var secondsElapsedWhenTimerPaused = 0
    
    /// Tracks the reorder toggle on speaker list
    private var reorderOn = false
    
    /// The undo stack is an array of tuples.  Each tuple holds: source table index, name position in source table, destination table index, name position in destination table and name of member.
    private var undoStack = [(Int, Int, Int, Int, String)]()
    
    private var speakerRecording = SpeakerRecording(row: nil, button: nil)
    
    private var sideBarIsHidden = true
    
    internal var eventRecordingIsOn = false
    
    private var longPressTablePosition: TablePosition?
    
    private var speakingTableNumberOfSections = 1
    private var speakingTableCurrentSection = 0
    

    // MARK: - Storyboard outlets

    // MARK: Table views
    /// There are three table views with lists of speakers.  This is the left table view, containing the starting list of names.    
       @IBOutlet weak var remainingTable: UITableView!
    
    /// There are three table views with lists of speakers.  This is the middle table view, containing the list of those wanting to speak.
    @IBOutlet weak var waitingTable: UITableView!
    
    /// There are three table views with lists of speakers.  This is the right table view, containing the current speaker and the list of those who have spoken.
    @IBOutlet weak var speakingTable: UITableView!
    
    // References to labels for purposes of tweaking appearance
    @IBOutlet private weak var remainingLabel: UILabel!
    @IBOutlet weak var waitingLabel: UILabel!
    @IBOutlet weak var speakingLabel: UILabel!
    
    // MARK: Timer buttons and labels
    @IBOutlet private weak var timerLabel: UILabel!
    @IBOutlet private weak var startButton: UIButton!
    @IBOutlet private weak var pauseButton: UIButton!
    @IBOutlet private weak var stopButton: UIButton!
    @IBOutlet private weak var smTimerLabel: UILabel!
    @IBOutlet private weak var smStartButton: UIButton!
    @IBOutlet private weak var smPauseButton: UIButton!
    @IBOutlet private weak var smStopButton: UIButton!
    
    // The view that dims the background when the large timer is displayed
    @IBOutlet private weak var dimmerView: UIView!
    
    /// Holds start, pause and stop buttons for large timer
    @IBOutlet private weak var stackView: UIStackView!
    
    // MARK: Buttons on right side of screen
    @IBOutlet private weak var expandButton: UIButton!
    @IBOutlet private weak var undoButton: UIButton!
    @IBOutlet private weak var resetButton: UIButton!
    @IBOutlet internal weak var recordingOnLabel: UILabel!
    
    // MARK: Sidebar, views and buttons
    @IBOutlet private weak var sideBarView: UIView!
    @IBOutlet private weak var sideBarLeadingConstraint: NSLayoutConstraint!
    @IBOutlet private weak var disclosureSideBarButtonView: UIView!
    @IBOutlet private weak var discloseSideBarButton: UIButton!
    @IBOutlet internal weak var selectEntityButton: UIButton!
    @IBOutlet internal weak var selectMeetingGroupButton: UIButton!
    @IBOutlet internal weak var selectEventButton: UIButton!
    @IBOutlet private weak var eventView: UIView!
    @IBOutlet internal weak var recordSwitch: UISwitch!
    @IBOutlet private weak var debateNote: UITextField!
    @IBOutlet internal weak var meetingGroupLabel: UILabel!
    
    
    // MARK: - Object lifecycle

    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }


    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }

    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    

    deinit {
        print("TrackSpeakersViewController deinitialising")
    }
    
    
    // MARK: - Setup

    private func setup() {
        let viewController = self
        let interactor = TrackSpeakersInteractor()
        let presenter = TrackSpeakersPresenter()
        let router = TrackSpeakersRouter()
        viewController.router = router
        viewController.interactor = interactor
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }


    
    // MARK: - View lifecycle

    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Appearance tweaks
        undoButton.layer.cornerRadius = 2
        resetButton.layer.cornerRadius = 2
        disclosureSideBarButtonView.layer.cornerRadius = 10
        disclosureSideBarButtonView.layer.maskedCorners = [.layerMaxXMaxYCorner, .layerMaxXMinYCorner]
        selectEntityButton.layer.cornerRadius = 10
        selectEntityButton.layer.masksToBounds = true
        selectMeetingGroupButton.layer.cornerRadius = 10
        selectMeetingGroupButton.layer.masksToBounds = true
        selectEventButton.layer.cornerRadius = 10
        selectEventButton.layer.masksToBounds = true
        
        // Set datasource and delegate for table views
        remainingTable.dataSource = self
        waitingTable.dataSource = self
        waitingTable.delegate = self
        speakingTable.dataSource = self
        speakingTable.delegate = self
        speakingTable.register(AmendmentHeaderView.self, forHeaderFooterViewReuseIdentifier: "AmendmentHeaderView")
        
        // At start up, hide timer views, ensure stackview is at back so does not intercept touches, hide sidebar and the view containing the event selectors
        dimmerView.isHidden = true
        timerLabel.isHidden = true
        startButton.isHidden = true
        pauseButton.isHidden = true
        stopButton.isHidden = true
        view.sendSubview(toBack:stackView)
        sideBarLeadingConstraint.constant = -370
        eventView.isHidden = true
        
        // If iPad Pro 12.9" make adjustments to row height
        let iPadScreenWidth = self.view.frame.size.width
        if iPadScreenWidth > 1300 {
            remainingTable.rowHeight = UITableViewAutomaticDimension
            remainingTable.rowHeight = 60
            remainingLabel.font = UIFont(name: "Arial", size: 20)
            waitingTable.rowHeight = 60
            waitingLabel.font = UIFont(name: "Arial", size: 20)
            speakingTable.rowHeight = 60
            speakingLabel.font = UIFont(name: "Arial", size: 20)
        }
        
        selectMeetingGroupButton.isEnabled = (selectEntityButton.titleLabel?.text == "Select an entity") ? false : true
        recordSwitch.isEnabled = (selectMeetingGroupButton.titleLabel?.text == "Select a meeting group") ? false : true
        
        let swipeGesture1 = UISwipeGestureRecognizer(target: self, action: #selector(handleSwipeGesture(_:)))
        swipeGesture1.direction = .right
        self.remainingTable.addGestureRecognizer(swipeGesture1)
        
        let swipeGesture2a = UISwipeGestureRecognizer(target: self, action: #selector(handleSwipeGesture(_:)))
        swipeGesture2a.direction = .left
        let swipeGesture2b = UISwipeGestureRecognizer(target: self, action: #selector(handleSwipeGesture(_:)))
        swipeGesture2b.direction = .right
        self.waitingTable.addGestureRecognizer(swipeGesture2a)
        self.waitingTable.addGestureRecognizer(swipeGesture2b)
        
        let swipeGesture3 = UISwipeGestureRecognizer(target: self, action: #selector(handleSwipeGesture(_:)))
        swipeGesture3.direction = .left
        self.speakingTable.addGestureRecognizer(swipeGesture3)
        
        let longPressGesture = UILongPressGestureRecognizer(target: self, action: #selector(handleLongPressGesture(_:)))
        self.speakingTable.addGestureRecognizer(longPressGesture)
        let nameDictionary = [0 : ["test"]]
        tableCollection = [(remainingTable, nameDictionary), (waitingTable, nameDictionary), (speakingTable, nameDictionary)]

    }
    
    
    /*
     Adjust tab bar of original UITabBarController once views have loaded
     */
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        let tabBarCont = UIApplication.shared.keyWindow?.rootViewController as! UITabBarController
        let tabBarRect = tabBarCont.tabBar.frame
        tabBarCont.tabBar.frame = CGRect(x: view.frame.origin.x, y: tabBarRect.origin.y, width: view.frame.size.width, height: tabBarRect.size.height)
        
        // Get stored entities and meeting groups from user defaults
        if let entity = UserDefaultsManager.getCurrentEntity() {
            selectEntityButton.setTitle(entity.name, for: .normal)
            selectEntityButton.setTitleColor(UIColor.white, for: .normal)
            setCurrentEntity(entity: entity)
            selectMeetingGroupButton.isEnabled = true
        }
        if let meetingGroup = UserDefaultsManager.getCurrentMeetingGroup() {
            let checkIfBelongsToEntity = meetingGroupBelongsToCurrentEntity(meetingGroup: meetingGroup)
            if checkIfBelongsToEntity {
                selectMeetingGroupButton.setTitle(meetingGroup.name, for: .normal)
                selectMeetingGroupButton.setTitleColor(UIColor.white, for: .normal)
                setCurrentMeetingGroup(meetingGroup: meetingGroup)
                meetingGroupLabel.text = meetingGroup.name
                meetingGroupLabel.textColor = UIColor(white: 0.94, alpha: 1.0)
                recordSwitch.isEnabled = true
            }
            else {
                selectMeetingGroupButton.setTitle("", for: .normal)
                meetingGroupLabel.text = "〈  Select a meeting group in side-bar"
            }
            fetchNames()
        }
    }
        
    
    // MARK: - Storyboard actions
    
    // MARK: Sidebar buttons
    @IBAction private func discloseSideBarPressed(_ sender: UIButton) {
        if sideBarIsHidden == true {
            sideBarIsHidden = false
            sender.setTitle("◀︎", for: .normal)
            UIView.animate(withDuration: 1.0, animations: {
                self.sideBarLeadingConstraint.constant = 0
                self.view.layoutIfNeeded()
            })
        }
        else {
            sideBarIsHidden = true
            sender.setTitle("▶︎", for: .normal)
            UIView.animate(withDuration: 1.0, animations: {
                self.sideBarLeadingConstraint.constant = -370
                self.view.layoutIfNeeded()
            })
        }
    }
    
    @IBAction private func selectEntityPressed(_ button: UIButton) {
        router!.routeToSelectEntity(button: button)
    }
    
    @IBAction private func selectMeetingGroupPressed(_ button: UIButton) {
        router!.routeToSelectMeetingGroup(button: button)
    }
    
    @IBAction private func selectEventPressed(_ button: UIButton) {
        router?.routeToSelectEvent(button: button)
    }
    
    @IBAction private func recordSwitchPressed(_ sender: UISwitch) {
        if sender.isOn == true {
            eventView.isHidden = false
        }
        else {
            eventView.isHidden = true
            recordingOnLabel.textColor = UIColor.darkGray
            eventRecordingIsOn = false
            addCurrentDebateToEvent()
        }
    }
    
    
    // MARK: Table view row buttons
    
    /**
     A storyboard button action.  The right button on a base-list table row was pressed.
     Gets name of member and passes this to helper function which moves name to table on right.
     */
        
    @IBAction func remainingTableRightButtonPressed(_ sender: UIButton, forEvent event: UIEvent) {

        let touch = event.allTouches?.first
        let pointInTable = touch?.location(in: remainingTable)
        let index = remainingTable.indexPathForRow(at: pointInTable!)
        moveNameRight(from: TablePosition(tableIndex: 0, tableSection: index?.section, tableRow: index?.row))
    }


    
    /**
     * A storyboard button action.  The left button on a speaker-list table row was pressed.
     * Gets name of member and passes this to helper function which moves name to table on left.
     */
    
    @IBAction func waitingTableLeftButtonPressed(_ sender: UIButton, forEvent event: UIEvent) {
        let touch = event.allTouches?.first
        let pointInTable = touch?.location(in: waitingTable)
        let index = waitingTable.indexPathForRow(at: pointInTable!)
        moveNameLeft(from: TablePosition(tableIndex: 1, tableSection: index?.section, tableRow: index?.row))
    }
    
    /**
     * A storyboard button action.  The right button on a speaker-list table row was pressed.
     * Gets name of member and passes this to helper function which moves name to table on right.
     */
    
    @IBAction func waitingTableRightButtonPressed(_ sender: UIButton, forEvent event: UIEvent) {

        let touch = event.allTouches?.first
        let pointInTable = touch?.location(in: waitingTable)
        let index = waitingTable.indexPathForRow(at: pointInTable!)
        moveNameRight(from: TablePosition(tableIndex: 1, tableSection: index?.section, tableRow: index?.row))
    }
    
    /**
     * A storyboard button action.  The left button on a done-list table row was pressed.
     * Gets name of member and passes this to helper function which moves name to table on left.
     */
    
    @IBAction func speakingTableLeftButtonPressed(_ sender: UIButton, forEvent event: UIEvent) {
        let touch = event.allTouches?.first
        let pointInTable = touch?.location(in: speakingTable)
        let index = speakingTable.indexPathForRow(at: pointInTable!)
        if speakerRecording.row == index!.row {
            _ = handleStopTimer()
        }
        let cell = speakingTable.cellForRow(at: index!) as! WMTableViewCell
        cell.rightButton?.setTitleColor(UIColor(red: 0, green: 0.48, blue: 1.0, alpha: 1.0), for: .normal)
        cell.rightButton?.setTitle("▶︎", for: .normal)
        cell.rightButton!.titleLabel!.font = UIFont.systemFont(ofSize: 22)
        moveNameLeft(from: TablePosition(tableIndex: 2, tableSection: index?.section, tableRow: index?.row))
    }
    
    /*
     If current speaker is on different row:
     - turn off current speaker if still speaking (check status of start button)
     - start timer for this speaker.
     If current speaker is this speaker:
     - stop this speaker
     */
    
    
    @IBAction func speakingTableRightButtonPressed(_ sender: UIButton, forEvent event: UIEvent) {
        let touch = event.allTouches?.first
        let pointInTable = touch?.location(in: speakingTable)
        let index = speakingTable.indexPathForRow(at: pointInTable!)
        if speakerRecording.row != index!.row {
            if smStartButton.isEnabled == false {
                _ = handleStopTimer()
            }
            speakerRecording.row = index?.row
            speakerRecording.button = sender
            sender.setTitleColor(UIColor.red, for: .normal)
            sender.setTitle("00:00", for: .normal)
            sender.titleLabel!.font = UIFont.systemFont(ofSize:14)
            handleStartTimer()
            setCurrentSpeaker(section: (index?.section)! , row: index!.row)
        }
        else {
            if smStartButton.isEnabled == false {
                _ = handleStopTimer()
            }
            speakerRecording = SpeakerRecording(row: nil, button: nil)
        }
    }
    
    @IBAction private func reorderButton(_ sender: UIButton) {
        
        if reorderOn == false {
            let (_, speakerArray) = tableCollection[1]
            if speakerArray!.count > 1 {
                waitingTable.isEditing = true
                reorderOn = true
                sender.tintColor = UIColor(red: 0.6, green: 0.6, blue: 1.0, alpha: 1.0)
                remainingTable.isUserInteractionEnabled = false
                speakingTable.isUserInteractionEnabled = false
                for cell in waitingTable.visibleCells {
                    (cell as! WMTableViewCell).leftButton?.isHidden = true
                    (cell as! WMTableViewCell).rightButton?.isHidden = true
                    (cell as! WMTableViewCell).setNeedsUpdateConstraints()
                }
            }
        } else {
            waitingTable.isEditing = false
            reorderOn = false
            sender.tintColor = UIColor.lightGray
            remainingTable.isUserInteractionEnabled = true
            speakingTable.isUserInteractionEnabled = true
            for cell in waitingTable.visibleCells {
                (cell as! WMTableViewCell).leftButton?.isHidden = false
                (cell as! WMTableViewCell).rightButton?.isHidden = false
                (cell as! WMTableViewCell).setNeedsUpdateConstraints()
            }
        }
    }
    
    
    // MARK: Controls
    
    /**
     Resets all lists and the undo stack.
     */
    @IBAction private func resetAll(_ sender: UIButton) {
        var (_, nameDictionary): (UITableView, [Int : [String]]?)
        (_, nameDictionary) = tableCollection[2]
        for duple in nameDictionary! {
            let namesArray = duple.value
            for idx in 0..<namesArray.count {
                let cell = speakingTable.cellForRow(at: IndexPath(row: idx, section: duple.key)) as! WMTableViewCell
                cell.rightButton?.setTitleColor(UIColor(red: 0, green: 0.48, blue: 1.0, alpha: 1.0), for: .normal)
                cell.rightButton?.setTitle("▶︎", for: .normal)
                cell.rightButton!.titleLabel!.font = UIFont.systemFont(ofSize: 22)
            }
        }
        if smStartButton.isEnabled == false {
            _ = handleStopTimer()
        }
        resetAllNames()
        if eventRecordingIsOn == true {
            addCurrentDebateToEvent()
        }
    }
    
    
    /**
     A storyboard button action:  the undo button was pressed.
     
     The undo stack comprises an array of tuples.
     Each tuple holds: source table index, name position in source table, destination table index, name position in destination table and name of member.
     
     When the undo button is pressed, the last tuple in the array is popped off the array and the action reversed.
     */
    @IBAction private func undoPressed(_ sender: UIButton) {
        undoLastAction()
    }
    
    
    // MARK: Timer buttons
    /**
     * A storyboard button action.  When the button is pressed, the large timer is toggled on and off.
     */
    @IBAction private func showLargeTimer(_ sender: UIButton) {
        
        if timerVisible == false {
            dimmerView.isHidden = false
            timerLabel.isHidden = false
            startButton.isHidden = false
            startButton.isEnabled = true
            pauseButton.isHidden = false
            pauseButton.isEnabled = true
            stopButton.isHidden = false
            stopButton.isEnabled = true
            timerVisible = true
            view.bringSubview(toFront: dimmerView)
            view.bringSubview(toFront: timerLabel)
            view.bringSubview(toFront: stackView)
            view.bringSubview(toFront: startButton)
            view.bringSubview(toFront: pauseButton)
            view.bringSubview(toFront: stopButton)
            expandButton.setImage(UIImage(named: "shrink2"), for: .normal)
        } else {
            dimmerView.isHidden = true
            timerLabel.isHidden = true
            startButton.isHidden = true
            startButton.isEnabled = false
            pauseButton.isHidden = true
            pauseButton.isEnabled = false
            stopButton.isHidden = true
            stopButton.isEnabled = false
            timerVisible = false
            view.sendSubview(toBack:stackView)
            expandButton.setImage(UIImage(named: "expand2"), for: .normal)
        }
    }
    
    
    /**
     * A storyboard button action.  The large timer's start button was pressed.
     */
    @IBAction private func startTimer(_ sender: UIButton) {
        handleStartTimer()
    }
    
    
    /**
     * A storyboard button action.  The small timer's start button was pressed.
     */
    @IBAction private func startSmTimer(_ sender: UIButton) {
        handleStartTimer()
    }
    
    @IBAction private func pauseTimer(_ sender: UIButton) {
        handlePauseTimer()
    }
    
    @IBAction private func pauseSmTimer(_ sender: UIButton) {
        handlePauseTimer()
    }
    
    @IBAction private func stopTimer(_ sender: UIButton) {
        _ = handleStopTimer()
    }
    
    @IBAction private func stopSmTimer(_ sender: UIButton) {
        _ = handleStopTimer()
    }
    
    
    // MARK: - Datastore

    private func setCurrentEntity(entity: Entity) {
         interactor?.setCurrentEntity(entity: entity)
    }
    
    private func getCurrentEntity() -> Entity? {
        return interactor!.getCurrentEntity()
    }
    
    private func setCurrentMeetingGroup(meetingGroup: MeetingGroup) {
        interactor?.setCurrentMeetingGroup(meetingGroup: meetingGroup)
    }
    
    private func getCurrentMeetingGroup()-> MeetingGroup? {
        return interactor?.getCurrentMeetingGroup()
    }
    
    private func meetingGroupBelongsToCurrentEntity(meetingGroup: MeetingGroup) -> Bool {
        return interactor!.meetingGroupBelongsToCurrentEntity(meetingGroup: meetingGroup)
    }

    private func setCurrentSpeaker(section: Int, row: Int) {
        interactor!.setCurrentSpeaker(section: section, row: row)
    }
    
    private func addCurrentSpeakerToDebate(debateNote: String, startTime: Date, speakingTime: Int) {
        interactor!.addCurrentSpeakerToDebate(debateNote: debateNote, startTime: startTime, speakingTime: speakingTime)
    }
    
    private func setCurrentEvent(event: Event?) {
        interactor!.setCurrentEvent(event: event)
    }
    
    private func addCurrentDebateToEvent() {
        interactor?.addCurrentDebateToEvent()
    }
    
    
    // MARK: - VIP
    
    private func fetchNames() {
        interactor!.fetchNames()
    }
    
   func displayNames(viewModel: TrackSpeakers.Speakers.ViewModel) {
        tableCollection = [(remainingTable, viewModel.remainingNames!), (waitingTable, viewModel.waitingNames!), (speakingTable, viewModel.speakingNames!)]
        remainingTable.reloadData()
        waitingTable.reloadData()
        speakingTable.reloadData()
    }
    
    private func moveNameRight(from tablePosition: TablePosition ) {
        interactor!.moveNameRight(from: tablePosition)
        fetchNames()
    }
    
    private func moveNameLeft(from tablePosition: TablePosition ) {
        interactor!.moveNameLeft(from: tablePosition)
        fetchNames()
    }
    
    private func copyNameToEnd(from tablePosition: TablePosition ) {
        interactor!.copyNameToEnd(from: tablePosition)
        fetchNames()
    }
    
    private func resetAllNames() {
        interactor!.resetAllNames()
        fetchNames()
    }
    
    private func undoLastAction() {
        interactor!.undoLastAction()
        fetchNames()
    }
    
    func updateAfterSelectingMeetingGroup() {
        interactor?.updateAfterSelectingMeetingGroup()
        fetchNames()
    }
  
    func updateAfterSelectingEvent() {
        interactor?.updateAfterSelectingEvent()
//        fetchNames()
    }
    
    func beginAmendment() {
        speakingTableNumberOfSections += 1
        interactor!.beginAmendment()
        fetchNames()
    }
    
    
    //MARK: - UITableViewDataSource protocols
    
    func numberOfSections(in tableView: UITableView) -> Int {
        switch tableView.tag {
        case 1:
            return 1
        case 2:
            return 1
        case 3:
            return speakingTableNumberOfSections
        default:
            return 0
        }
    }
    
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {

            let tag = tableView.tag
            var (_, nameDictionary): (UITableView, [Int : [String]]?)
            var numRows: Int?
            
            switch tag {
            case 1:
                (_,nameDictionary) = tableCollection[0]
                numRows = nameDictionary![section]!.count
            case 2:
                (_,nameDictionary) = tableCollection[1]
                numRows = nameDictionary![section]!.count
            case 3:
                (_,nameDictionary) = tableCollection[2]
                numRows = nameDictionary![section]!.count
            default:
                break
            }
            
            return numRows!

    }
    
    
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        var tvCell = tableView.dequeueReusableCell(withIdentifier: "wmcell", for: indexPath) as? WMTableViewCell
        if tvCell == nil {
            tvCell = WMTableViewCell(style: .default, reuseIdentifier: "wmcell")
        }
        
        let tag = tableView.tag
        
        switch tag {
        case 1:
            var name = ""
            var (_,nameDictionary) = tableCollection[0]
            if nameDictionary!.count > 0  {
                name = nameDictionary![indexPath.section]![indexPath.row]
            }
            tvCell!.isSpeakingTableCell = false
            tvCell?.memberText?.text = name
            if self.view.frame.size.width > 1300 {tvCell?.memberText?.font = UIFont(name: "Arial", size: 28)} // if iPad Pro 12"
            
        case 2:
            var name = ""
            var (_,nameDictionary) = tableCollection[1]
            if nameDictionary!.count > 0  {
                name = nameDictionary![indexPath.section]![indexPath.row]
            }
            tvCell!.isSpeakingTableCell = false
            tvCell?.memberText!.text = name
            if self.view.frame.size.width > 1300 {tvCell?.memberText?.font = UIFont(name: "Arial", size: 28)} // if iPad Pro 12"
            
        case 3:
            var name = ""
            var (_,nameDictionary) = tableCollection[2]
            if nameDictionary!.count > 0  {
                name = nameDictionary![indexPath.section]![indexPath.row]
            }
            tvCell!.isSpeakingTableCell = true
            tvCell?.memberText!.text = name
            if self.view.frame.size.width > 1300 {tvCell?.memberText?.font = UIFont(name: "Arial", size: 28)} // if iPad Pro 12"

        default:
            break
        }
        
        return tvCell!
    }
    
    
    func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
        
        var (_, waitingNameDictionary) = tableCollection[1]
        let nameToMove = waitingNameDictionary![sourceIndexPath.section]!.remove(at: sourceIndexPath.row)
        waitingNameDictionary![destinationIndexPath.section]!.insert(nameToMove, at: destinationIndexPath.row)
        tableCollection[1] = (waitingTable, waitingNameDictionary)
        
        undoStack.append((1, sourceIndexPath.row, 1, destinationIndexPath.row, waitingNameDictionary![destinationIndexPath.section]![destinationIndexPath.row]))
        if undoStack.count > 10 {
            let newStack = Array(undoStack.dropFirst())
            undoStack = newStack
        }
    }
    
    
    // MARK: - UITableView delegate methods
    
    func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -> UITableViewCellEditingStyle {
        // Don't want a delete or insert accessory
        return .none
    }
    
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        if tableView.tag == 3 {
            var header = tableView.dequeueReusableHeaderFooterView(withIdentifier: "AmendmentHeaderView") as? AmendmentHeaderView
            if header == nil {
                header = AmendmentHeaderView(reuseIdentifier: "AmendmentHeaderView")
            }
            if section % 2 == 1 {
                header!.amendmentLabel?.text = "Amendment"
            }
            if section % 2 == 0 {
                header!.amendmentLabel?.text = "Main motion"
            }
            return header
        }
        return nil
    }
    
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        if tableView.tag == 3 {
            return 32
        }
        return 0
    }
    
    
 
    
    // MARK: - Handle gestures
    
    
    override var canBecomeFirstResponder: Bool {
        get {
            return true
        }
    }
    
    
    /// Get the member's name and index of table that was swiped and pass to functions to move name left or right.
    @objc private func handleSwipeGesture(_ recognizer: UISwipeGestureRecognizer) {
        guard recognizer.state == .ended else { return }
        guard recognizer.view is UITableView else { return }
        var currentTable: UITableView?
        var tableIndex = 0
        
        switch recognizer.view!.tag {
        case 1:
            guard recognizer.direction == .right else { return }
            currentTable = remainingTable
            tableIndex = 0
        case 2:
            currentTable = waitingTable
            tableIndex = 1
        case 3:
            guard recognizer.direction == .left else { return }
            currentTable = speakingTable
            tableIndex = 2
        default:
            currentTable = nil
        }
        
        let swipeLocation = recognizer.location(in: currentTable)
        guard let swipedIndexPath = currentTable?.indexPathForRow(at: swipeLocation)  else { return }
        if recognizer.direction == .left {
            moveNameLeft(from: TablePosition(tableIndex: tableIndex, tableSection: swipedIndexPath.section, tableRow: swipedIndexPath.row))
        }
        if recognizer.direction == .right {
            moveNameRight(from: TablePosition(tableIndex: tableIndex, tableSection: swipedIndexPath.section, tableRow: swipedIndexPath.row))
        }
    }
    
    
    @objc func handleLongPressGesture(_ recognizer: UILongPressGestureRecognizer) {
        becomeFirstResponder()
        let pressLocation = recognizer.location(in: speakingTable)
        guard let pressIndexPath = speakingTable?.indexPathForRow(at: pressLocation)  else { return }
        let cell = speakingTable.cellForRow(at: pressIndexPath)
        let menuController = UIMenuController.shared
        menuController.setTargetRect((cell?.contentView.frame)!, in: (cell?.contentView)!)
        var item: UIMenuItem?
        if pressIndexPath.section == 0 && pressIndexPath.row == 0 {
            longPressTablePosition = TablePosition(tableIndex: 2, tableSection: 0, tableRow: 0)
            menuController.arrowDirection = .up
            item = UIMenuItem(title: "Exercises right of reply", action: #selector(exerciseRightOfReply))
            menuController.menuItems = [item!]
            menuController.setMenuVisible(true, animated: true)
        }
        let (_,nameDictionary) = tableCollection[2]
        if pressIndexPath.row == nameDictionary![pressIndexPath.section]!.count - 1 {
            item = UIMenuItem(title: "Moves amendment", action: #selector(moveAmendment))
            menuController.menuItems = [item!]
            menuController.setMenuVisible(true, animated: true)
        }
    }
    
    
    @objc func exerciseRightOfReply() {
        copyNameToEnd(from: longPressTablePosition!)
    }
 
    @objc func moveAmendment() {
        beginAmendment()
//        speakingTableNumberOfSections += 1
//        var (_, nameDictionary) = tableCollection[2]
//        nameDictionary![speakingTableNumberOfSections - 1] = [String]()
//        tableCollection[2].1 = nameDictionary
//        fetchNames()
    }
    
    
    // MARK: - Timer handlers
    
    /**
     * Called every time the timer fires (every second).
     * Updates the timer displays.
     */
    
    @objc private func timerFireMethod(_ timer: Timer) {
        
        let secondsSinceStart: Int = abs(Int(startTime!.timeIntervalSinceNow))
        let minutes = secondsSinceStart / 60
        let seconds = secondsSinceStart - (minutes * 60)
        let secondsString = String(format: "%02d", seconds)
        let minutesString = String(format: "%02d", minutes)
        timerLabel.text = "\(minutesString):\(secondsString)"
        smTimerLabel.text = "\(minutesString):\(secondsString)"
        speakerRecording.button?.setTitle("\(minutesString):\(secondsString)", for: .normal)
    }
    
    
    /**
     Called when a timer's start button is pressed.
     It resets the timer display and creates a new instance of a Timer class to fire at 1 second intervals.
     On each fire, timerFireMethod(_: ) is called.
     Note: either create a timer using Timer.scheduledTimer(), which will be automatically added to runloop or Time() and add to runloop.
     https://www.hackingwithswift.com/articles/117/the-ultimate-guide-to-timer 
     */
    
    private func handleStartTimer() {
        if pausePressed != true {
            startTime = Date()
            timerLabel.text = "00:00"
            smTimerLabel.text = "00:00"
            
        } else {
            
            // Reset pause toggle
            pausePressed = false
            
            // New start time is 'now' less the number seconds showing when paused
            startTime = Date() - TimeInterval(secondsElapsedWhenTimerPaused)
        }
        
        startButton.isEnabled = false
        stopButton.isEnabled = true
        pauseButton.isEnabled = true
        smStartButton.isEnabled = false
        smStopButton.isEnabled = true
        smPauseButton.isEnabled = true
        
        timer?.invalidate()
        timer = Timer(timeInterval: 1.0, target: self, selector: #selector(timerFireMethod(_: )), userInfo: nil, repeats: true )
        RunLoop.current.add(timer!, forMode: .commonModes)
    }
    
    
    /**
     Called when either pause button is pressed
     */
    
    private func handlePauseTimer() {
        
        // Set pause toggle
        pausePressed = true
        
        // Stop firing timer events
        timer?.invalidate()
        
        // Get seconds since timer started. Add this when restarting the timer so does not start from zero.
        secondsElapsedWhenTimerPaused = abs(Int(startTime!.timeIntervalSinceNow))
        
        // Re-enable start button and disable pause button
        startButton.isEnabled = true
        pauseButton.isEnabled = false
        stopButton.isEnabled = true
        smStartButton.isEnabled = true
        smPauseButton.isEnabled = false
        smStopButton.isEnabled = true
    }
    
    
    /// Called when either stop button is pressed
    private func handleStopTimer() -> Int {
        timer?.invalidate()
        startButton.isEnabled = true
        pauseButton.isEnabled = false
        stopButton.isEnabled = false
        smStartButton.isEnabled = true
        smPauseButton.isEnabled = false
        smStopButton.isEnabled = false
        let speakingTime = abs(Int(startTime!.timeIntervalSinceNow))
        if eventRecordingIsOn == true {
            addCurrentSpeakerToDebate(debateNote: debateNote.text!, startTime: startTime!, speakingTime: speakingTime)
        }
        return speakingTime
    }
}
