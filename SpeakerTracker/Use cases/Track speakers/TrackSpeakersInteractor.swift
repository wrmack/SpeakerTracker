//
//  TrackSpeakersInteractor.swift
//  SpeakerTracker
//
//  Created by Warwick McNaughton on 14/09/18.
//  Copyright (c) 2018 Warwick McNaughton. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol TrackSpeakersBusinessLogic {
    func setCurrentEntity(entity: Entity)
    func getCurrentEntity()-> Entity?
    func setCurrentMeetingGroup(meetingGroup: MeetingGroup)
    func getCurrentMeetingGroup()->MeetingGroup?
    func setCurrentEvent(event: Event?) 
    func fetchNames()
    func moveNameRight(from tablePosition: TablePosition )
    func moveNameLeft(from tablePosition: TablePosition )
    func copyNameToEnd(from tablePosition: TablePosition )
    func resetAllNames()
    func beginAmendment()
    func undoLastAction()
    func setCurrentSpeaker(section:Int, row: Int)
    func addCurrentSpeakerToDebate(debateNote: String, startTime: Date, speakingTime: Int)
    func addCurrentDebateToEvent()
    func meetingGroupBelongsToCurrentEntity(meetingGroup: MeetingGroup) ->Bool
    func updateAfterSelectingMeetingGroup()
    func updateAfterSelectingEvent()
}

protocol TrackSpeakersDataStore {
    var currentEntity: Entity? {get set}
    var currentMeetingGroup: MeetingGroup? {get set}
    var currentEvent: Event? {get set}
}


class TrackSpeakersInteractor: TrackSpeakersBusinessLogic, TrackSpeakersDataStore { 
    var presenter: TrackSpeakersPresentationLogic?
    var currentEntity: Entity?
    var currentMeetingGroup: MeetingGroup?
    var currentSpeaker: Member?
    var currentEvent: Event?
    var currentDebate: Debate?
    var remainingList = [Int : [Member]]()
    var waitingList = [Int : [Member]]()
    var speakingList = [Int : [Member]]()
    var speakingListCurrentSection = 0
    var undoStack = UndoStack(speakerMovements: [SpeakerMovement]())

    
    
    // MARK: - Datastore

    func setCurrentEntity(entity: Entity) {
        currentEntity = entity
    }
    
    
    func getCurrentEntity()-> Entity? {
        return currentEntity
    }
 
    func setCurrentMeetingGroup(meetingGroup: MeetingGroup) {
        currentMeetingGroup = meetingGroup
        if currentMeetingGroup?.members == nil {
            currentMeetingGroup?.members = [Member]()
        }
        remainingList[0] = currentMeetingGroup!.members!
        waitingList[0] = [Member]()
        speakingList[0] = [Member]()
    }
    
    func getCurrentMeetingGroup()->MeetingGroup? {
        return currentMeetingGroup
    }
    
    func setCurrentSpeaker(section:Int, row: Int) {
        currentSpeaker = speakingList[section]![row]
    }
    
    
    func setCurrentEvent(event: Event?) {
        currentEvent = event
        currentEvent?.debates = [Debate]()
    }
    
    func addCurrentSpeakerToDebate(debateNote: String, startTime: Date, speakingTime: Int) {
        let minutes = speakingTime / 60
        let seconds = speakingTime - (minutes * 60)
        let speakerEvent = SpeakerEvent(member: currentSpeaker, elapsedMinutes: minutes, elapsedSeconds: seconds, startTime: startTime)
        if currentDebate == nil {
            currentDebate = Debate(debateNumber: (currentEvent?.debates!.count)! + 1, note: debateNote, speakerEvents: [SpeakerEvent]())
        }
        currentDebate?.speakerEvents?.append(speakerEvent) 
    }
    
    
    /*
     Called when Reset is pressed
     */
    func addCurrentDebateToEvent() {
         if currentEvent?.debates == nil {
            currentEvent?.debates = [Debate]()
        }
        if currentDebate != nil {
            currentEvent?.debates?.append(currentDebate!)
        }
        currentDebate = nil
        if currentEvent != nil {
            saveCurrentEvent()
        }
    }
    
    
    func saveCurrentEvent() {
        let fileManager = FileManager.default
        guard let docDirectory = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else {
            print("TrackSpeakersInteractor: saveCurrentEvent: error: Document directory not found")
            return
        }
        let eventURL = docDirectory.appendingPathComponent((currentEvent?.filename)! + ".evt")
        let eventDoc = EventDocument(fileURL: eventURL)
        eventDoc.open(completionHandler: { success in
            if !success {
                print("TrackSpeakersInteractor: saveCurrentEvent: error opening EventDocument")
            }
            else {
                eventDoc.event = self.currentEvent
                eventDoc.updateChangeCount(.done)
                eventDoc.close(completionHandler: { success in
                    if success == false {
                        print("TrackSpeakersInteractor: saveCurrentEvent: error closing EventDocument")
                    }
                })
            }
        })
    }
    

    func updateAfterSelectingMeetingGroup() {
        if currentMeetingGroup?.members == nil {
            currentMeetingGroup?.members = [Member]()
        }
        remainingList[0] = currentMeetingGroup!.members!
        waitingList[0] = [Member]()
        speakingList[0] = [Member]()
        UserDefaultsManager.saveCurrentEntity(entity: self.currentEntity!)
        UserDefaultsManager.saveCurrentMeetingGroup(meetingGroup: self.currentMeetingGroup!)
    }
    
    func updateAfterSelectingEvent() {
        self.currentEvent?.debates = [Debate]()
    }
    
    // MARK: - VIP
    
    func fetchNames() {
        let response = TrackSpeakers.Speakers.Response(remainingList: remainingList, waitingList: waitingList, speakingList: speakingList)
        presenter?.presentNames(response: response)
    }
    
    
    func moveNameRight(from tablePosition: TablePosition ) {
        
        switch tablePosition.tableIndex {
        case 0:
            let member = remainingList[0]!.remove(at: tablePosition.tableRow!)
            waitingList[0]!.append(member)
            var speakerMvt = SpeakerMovement()
            speakerMvt.sourceTablePosition = tablePosition
            speakerMvt.destinationTablePosition = TablePosition(tableIndex: 1, tableSection: 0, tableRow: waitingList.count - 1)
            speakerMvt.member = member
            undoStack.speakerMovements.append(speakerMvt)
        case 1:
            let member = waitingList[0]!.remove(at: tablePosition.tableRow!)
            speakingList[speakingListCurrentSection]!.append(member)
            var speakerMvt = SpeakerMovement()
            speakerMvt.sourceTablePosition = tablePosition
            speakerMvt.destinationTablePosition = TablePosition(tableIndex: 2, tableSection: speakingListCurrentSection, tableRow: speakingList.count - 1)
            speakerMvt.member = member
            undoStack.speakerMovements.append(speakerMvt)
        default:
            print("TrackSpeakersInteractor: moveNameRight: case not covered")
        }
    }
    
    
    func moveNameLeft(from tablePosition: TablePosition ) {
        switch tablePosition.tableIndex {
        case 1:
            let member = waitingList[0]!.remove(at: tablePosition.tableRow!)
            let originalBaseList = currentMeetingGroup?.members
            let indexOfMemberInOriginalBaseList = originalBaseList?.firstIndex(where: {$0 == member})
            if remainingList.count <= indexOfMemberInOriginalBaseList! {
                remainingList[0]!.append(member)
            }
            else {
                var counter = 0
                for _ in remainingList {
                    if counter >= indexOfMemberInOriginalBaseList! {
                        remainingList[0]!.insert(member, at: counter)
                        break
                    }
                    counter += 1
                }
            }
            var speakerMvt = SpeakerMovement()
            speakerMvt.sourceTablePosition = tablePosition
            speakerMvt.destinationTablePosition = TablePosition(tableIndex: 0, tableSection: 0, tableRow: remainingList.count - 1)
            speakerMvt.member = member
            undoStack.speakerMovements.append(speakerMvt)
        case 2:
            let member = speakingList[speakingListCurrentSection]!.remove(at: tablePosition.tableRow!)
            waitingList[0]!.append(member)
            var speakerMvt = SpeakerMovement()
            speakerMvt.sourceTablePosition = tablePosition
            speakerMvt.destinationTablePosition = TablePosition(tableIndex: 1, tableSection: speakingListCurrentSection,tableRow: waitingList.count - 1)
            speakerMvt.member = member
            undoStack.speakerMovements.append(speakerMvt)
        default:
            print("TrackSpeakersInteractor: moveNameRight: case not covered")
        }
    }
    
    func copyNameToEnd(from tablePosition: TablePosition ) {
        let member = speakingList[tablePosition.tableSection!]![tablePosition.tableRow!]
        speakingList[speakingListCurrentSection]!.append(member)
    }
    
    func resetAllNames() {
        remainingList[0] = (currentMeetingGroup?.members)!
        waitingList[0] = [Member]()
        speakingList[0] = [Member]()
    }
    
    
    func beginAmendment() {
        remainingList[0] = (currentMeetingGroup?.members)!
        waitingList[0] = [Member]()
        speakingListCurrentSection += 1
        speakingList[speakingListCurrentSection] = [Member]()
    }
    
    func undoLastAction() {
        let speakerMvt = undoStack.speakerMovements.popLast()
        let member = speakerMvt?.member
        switch speakerMvt?.destinationTablePosition?.tableIndex {
        case 0:
            _ = remainingList[0]!.remove(at: (speakerMvt!.destinationTablePosition?.tableRow)!)
        case 1:
            _ = waitingList[0]!.remove(at: (speakerMvt!.destinationTablePosition?.tableRow)!)
        case 2:
            _ = speakingList[speakingListCurrentSection]!.remove(at: (speakerMvt!.destinationTablePosition?.tableRow)!)
        default:
            break
        }
        switch speakerMvt?.sourceTablePosition?.tableIndex {
        case 0:
            remainingList[0]!.insert(member!, at: (speakerMvt?.sourceTablePosition?.tableRow)!)
        case 1:
            waitingList[0]!.insert(member!, at: (speakerMvt?.sourceTablePosition?.tableRow)!)
        case 2:
            speakingList[speakingListCurrentSection]!.insert(member!, at: (speakerMvt?.sourceTablePosition?.tableRow)!)
        default:
            break
        }
    }
    
    
    func meetingGroupBelongsToCurrentEntity(meetingGroup: MeetingGroup) ->Bool {
        var result = false
        if let ent = currentEntity {
            if let groups = ent.meetingGroups {
                for mg in groups {
                    if mg == meetingGroup {
                        result = true
                    }
                }
            }
            return result
        }
        return false
    }
}
