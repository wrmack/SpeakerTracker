//
//  TrackSpeakersInteractor.swift
//  SpeakerTracker
//
//  Created by Warwick McNaughton on 14/09/18.
//  Copyright (c) 2018 Warwick McNaughton. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol TrackSpeakersBusinessLogic {
    func setCurrentEntity(entity: Entity)
    func getCurrentEntity()-> Entity?
    func setCurrentMeetingGroup(meetingGroup: MeetingGroup)
    func setCurrentEvent(event: Event?) 
    func fetchNames()
    func moveNameRight(from tablePosition: TablePosition )
    func moveNameLeft(from tablePosition: TablePosition )
    func resetAllNames()
    func undoLastAction()
    func setCurrentSpeaker(row: Int)
    func addCurrentSpeakerToDebate(debateReference: String, speakingTime: Int)
    func addCurrentDebateToEvent()
}

protocol TrackSpeakersDataStore {
//    var currentEntity: Entity? { get set }
//    var currentSubEntity: SubEntity? {get set}
//    var currentSpeaker: Member? {get set}
}


class TrackSpeakersInteractor: TrackSpeakersBusinessLogic, TrackSpeakersDataStore { 
    var presenter: TrackSpeakersPresentationLogic?
    var currentEntity: Entity?
    var currentMeetingGroup: MeetingGroup?
    var currentSpeaker: Member?
    var currentEvent: Event?
    var currentDebate: Debate?
    var baseList = [Member]()
    var speakerList = [Member]()
    var doneList = [Member]()
    var undoStack = UndoStack(speakerMovements: [SpeakerMovement]())

    
    
    // MARK: - Datastore

    func setCurrentEntity(entity: Entity) {
        currentEntity = entity
    }
    
    
    func getCurrentEntity()-> Entity? {
        return currentEntity
    }
 
    func setCurrentMeetingGroup(meetingGroup: MeetingGroup) {
        currentMeetingGroup = meetingGroup
        if currentMeetingGroup?.members == nil {
            currentMeetingGroup?.members = [Member]()
        }
        baseList = currentMeetingGroup!.members!
        speakerList = [Member]()
        doneList = [Member]()
    }
    
    
    func setCurrentSpeaker(row: Int) {
        currentSpeaker = doneList[row]
    }
    
    
    func setCurrentEvent(event: Event?) {
        currentEvent = event
    }
    
    func addCurrentSpeakerToDebate(debateReference: String, speakingTime: Int) {
        let minutes = speakingTime / 60
        let seconds = speakingTime - (minutes * 60)
        let speakerEvent = SpeakerEvent(member: currentSpeaker, elapsedMinutes: minutes, elapsedSeconds: seconds, startTime: nil)
        if currentDebate == nil {
            currentDebate = Debate(reference: debateReference, speakerEvents: [SpeakerEvent]())
        }
        currentDebate?.speakerEvents?.append(speakerEvent) 
    }
    
    
    /*
     Called when Reset is pressed
     */
    func addCurrentDebateToEvent() {
         if currentEvent?.debates == nil {
            currentEvent?.debates = [Debate]()
        }
        currentEvent?.debates?.append(currentDebate!)
        currentDebate = nil
        saveCurrentEvent()
    }
    
    
    func saveCurrentEvent() {
        let fileManager = FileManager.default
        guard let docDirectory = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else {
            print("TrackSpeakersInteractor: saveCurrentEvent: error: Document directory not found")
            return
        }
        let eventURL = docDirectory.appendingPathComponent((currentEvent?.filename)! + ".evt")
        let eventDoc = EventDocument(fileURL: eventURL)
        eventDoc.open(completionHandler: { success in
            if !success {
                print("TrackSpeakersInteractor: saveCurrentEvent: error opening EventDocument")
            }
            else {
                eventDoc.event = self.currentEvent
                eventDoc.updateChangeCount(.done)
                eventDoc.close(completionHandler: { success in
                    if success == false {
                        print("TrackSpeakersInteractor: saveCurrentEvent: error closing EventDocument")
                    }
                })
            }
        })
    }
    
    
    
    // MARK: - VIP
    
    func fetchNames() {
        let response = TrackSpeakers.Speakers.Response(baseList: baseList, speakerList: speakerList, doneList: doneList)
        presenter?.presentNames(response: response)
    }
    
    
    func moveNameRight(from tablePosition: TablePosition ) {
        
        switch tablePosition.tableIndex {
        case 0:
            let member = baseList.remove(at: tablePosition.tableRow!)
            speakerList.append(member)
            var speakerMvt = SpeakerMovement()
            speakerMvt.sourceTablePosition = tablePosition
            speakerMvt.destinationTablePosition = TablePosition(tableIndex: 1, tableRow: speakerList.count - 1)
            speakerMvt.member = member
            undoStack.speakerMovements.append(speakerMvt)
            fetchNames()
        case 1:
            let member = speakerList.remove(at: tablePosition.tableRow!)
            doneList.append(member)
            var speakerMvt = SpeakerMovement()
            speakerMvt.sourceTablePosition = tablePosition
            speakerMvt.destinationTablePosition = TablePosition(tableIndex: 2, tableRow: doneList.count - 1)
            speakerMvt.member = member
            undoStack.speakerMovements.append(speakerMvt)
            fetchNames()
        default:
            print("TrackSpeakersInteractor: moveNameRight: case not covered")
        }
    }
    
    
    func moveNameLeft(from tablePosition: TablePosition ) {
        switch tablePosition.tableIndex {
        case 1:
            let member = speakerList.remove(at: tablePosition.tableRow!)
            let originalBaseList = currentMeetingGroup?.members
            let indexOfMemberInOriginalBaseList = originalBaseList?.firstIndex(where: {$0 == member})
            if baseList.count <= indexOfMemberInOriginalBaseList! {
                baseList.append(member)
            }
            else {
                var counter = 0
                for _ in baseList {
                    if counter >= indexOfMemberInOriginalBaseList! {
                        baseList.insert(member, at: counter)
                        break
                    }
                    counter += 1
                }
            }
            var speakerMvt = SpeakerMovement()
            speakerMvt.sourceTablePosition = tablePosition
            speakerMvt.destinationTablePosition = TablePosition(tableIndex: 0, tableRow: baseList.count - 1)
            speakerMvt.member = member
            undoStack.speakerMovements.append(speakerMvt)
            fetchNames()
        case 2:
            let member = doneList.remove(at: tablePosition.tableRow!)
            speakerList.append(member)
            var speakerMvt = SpeakerMovement()
            speakerMvt.sourceTablePosition = tablePosition
            speakerMvt.destinationTablePosition = TablePosition(tableIndex: 1, tableRow: speakerList.count - 1)
            speakerMvt.member = member
            undoStack.speakerMovements.append(speakerMvt)
            fetchNames()
        default:
            print("TrackSpeakersInteractor: moveNameRight: case not covered")
        }
    }
    
    func resetAllNames() {
        baseList = (currentMeetingGroup?.members)!
        speakerList = [Member]()
        doneList = [Member]()
        fetchNames()
    }
    
    func undoLastAction() {
        let speakerMvt = undoStack.speakerMovements.popLast()
        let member = speakerMvt?.member
        switch speakerMvt?.destinationTablePosition?.tableIndex {
        case 0:
            _ = baseList.remove(at: (speakerMvt!.destinationTablePosition?.tableRow)!)
        case 1:
            _ = speakerList.remove(at: (speakerMvt!.destinationTablePosition?.tableRow)!)
        case 2:
            _ = doneList.remove(at: (speakerMvt!.destinationTablePosition?.tableRow)!)
        default:
            break
        }
        switch speakerMvt?.sourceTablePosition?.tableIndex {
        case 0:
            baseList.insert(member!, at: (speakerMvt?.sourceTablePosition?.tableRow)!)
        case 1:
            speakerList.insert(member!, at: (speakerMvt?.sourceTablePosition?.tableRow)!)
        case 2:
            doneList.insert(member!, at: (speakerMvt?.sourceTablePosition?.tableRow)!)
        default:
            break
        }
        fetchNames()
    }
}
