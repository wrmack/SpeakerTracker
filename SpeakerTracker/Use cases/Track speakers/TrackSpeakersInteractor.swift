//
//  TrackSpeakersInteractor.swift
//  SpeakerTracker
//
//  Created by Warwick McNaughton on 14/09/18.
//  Copyright (c) 2018 Warwick McNaughton. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol TrackSpeakersBusinessLogic {
    func setCurrentEntity(entity: Entity)
    func getCurrentEntity()-> Entity?
    func setCurrentMeetingGroup(meetingGroup: MeetingGroup)
    func getCurrentMeetingGroup()->MeetingGroup?
    func setCurrentEvent(event: Event?)
    func getCurrentEvent()-> Event?
    func fetchNames()
    func moveNameRight(from tablePosition: TablePosition )
    func moveNameLeft(from tablePosition: TablePosition )
    func copyNameToEnd(from tablePosition: TablePosition )
    func resetAllNames()
    func beginAmendment()
    func endAmendment()
    func undoLastAction()
    func setCurrentSpeaker(section:Int, row: Int)
    func addCurrentSpeakerToDebateSection(startTime: Date, speakingTime: Int)
    func addCurrentDebateSectionToDebate()
    func addCurrentDebateToEvent(debateNote: String)
    func meetingGroupBelongsToCurrentEntity(meetingGroup: MeetingGroup) ->Bool
    func updateAfterSelectingMeetingGroup()
    func updateAfterSelectingEvent()
    func getSpeakingListNumberOfSections() -> Int
}

protocol TrackSpeakersDataStore {
    var currentEntity: Entity? {get set}
    var currentMeetingGroup: MeetingGroup? {get set}
    var currentEvent: Event? {get set}
    var currentDebate: Debate? {get set}
}


class TrackSpeakersInteractor: TrackSpeakersBusinessLogic, TrackSpeakersDataStore { 
    var presenter: TrackSpeakersPresentationLogic?
    var currentEntity: Entity?
    var currentMeetingGroup: MeetingGroup?
    var currentSpeaker: Member?
    var currentEvent: Event?
    var currentDebate: Debate?
    var remainingList = [Int : [Member]]()
    var waitingList = [Int : [Member]]()
    var speakingList = [Int : [Member]]()
    var mainMotionRemainingList = [Int : [Member]]()
    var mainMotionWaitingList = [Int : [Member]]()
    var speakingListNumberOfDebates = 1
    var speakingListNumberOfSections = 1
    var undoStack = UndoStack(speakerMovements: [SpeakerMovement]())

    
    func setUpListsAndDebate() {
        remainingList[0] = currentMeetingGroup!.members!
        waitingList[0] = [Member]()
        speakingList[0] = [Member]()
        let debateSection = DebateSection(sectionNumber: 0, sectionName: "Main debate", speakerEvents: [SpeakerEvent]())
        currentDebate = Debate(debateNumber: 0, note: nil, debateSections: [debateSection])
    }
    
    
    // MARK: - Datastore

    func setCurrentEntity(entity: Entity) {
        currentEntity = entity
    }
    
    
    func getCurrentEntity()-> Entity? {
        return currentEntity
    }
 
    func setCurrentMeetingGroup(meetingGroup: MeetingGroup) {
        currentMeetingGroup = meetingGroup
        if currentMeetingGroup?.members == nil {
            currentMeetingGroup?.members = [Member]()
        }
        setUpListsAndDebate()
    }
    
    func getCurrentMeetingGroup()->MeetingGroup? {
        return currentMeetingGroup
    }
    
    func setCurrentSpeaker(section:Int, row: Int) {
        currentSpeaker = speakingList[section]![row]
//        if currentEvent == nil {
//            currentEvent = Event(date: Date(), entity: currentEntity, meetingGroup: currentMeetingGroup, note: nil, debates: [Debate](), id: nil, filename: nil)
//        }

    }
    
    func setCurrentEvent(event: Event?) {
        currentEvent = event
        currentEvent?.debates = [Debate]()
    }
    
    func getCurrentEvent()-> Event? {
        return currentEvent
    }
    
    func addCurrentSpeakerToDebateSection(startTime: Date, speakingTime: Int) {
        let minutes = speakingTime / 60
        let seconds = speakingTime - (minutes * 60)
        let speakerEvent = SpeakerEvent(member: currentSpeaker, elapsedMinutes: minutes, elapsedSeconds: seconds, startTime: startTime)
        currentDebate?.debateSections![speakingListNumberOfSections - 1].speakerEvents?.append(speakerEvent)
    }
    
    
    func addCurrentDebateSectionToDebate() {

    }
    
    
    /*
     Called when Reset is pressed
     */
    func addCurrentDebateToEvent(debateNote: String) {
        if currentDebate != nil {
            currentEvent?.debates?.append(currentDebate!)
        }
        currentDebate = nil
        if currentEvent != nil {
            saveCurrentEvent()
        }
    }
    
    
    func saveCurrentEvent() {
        let fileManager = FileManager.default
        guard let docDirectory = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else {
            print("TrackSpeakersInteractor: saveCurrentEvent: error: Document directory not found")
            return
        }
        let eventURL = docDirectory.appendingPathComponent((currentEvent?.filename)! + ".evt")
        let eventDoc = EventDocument(fileURL: eventURL)
        eventDoc.open(completionHandler: { success in
            if !success {
                print("TrackSpeakersInteractor: saveCurrentEvent: error opening EventDocument")
            }
            else {
                eventDoc.event = self.currentEvent
                eventDoc.updateChangeCount(.done)
                eventDoc.close(completionHandler: { success in
                    if success == false {
                        print("TrackSpeakersInteractor: saveCurrentEvent: error closing EventDocument")
                    }
                })
            }
        })
    }
    

    func updateAfterSelectingMeetingGroup() {
        if currentMeetingGroup?.members == nil {
            currentMeetingGroup?.members = [Member]()
        }
        remainingList[0] = currentMeetingGroup!.members!
        waitingList[0] = [Member]()
        speakingList[0] = [Member]()
        UserDefaultsManager.saveCurrentEntity(entity: self.currentEntity!)
        UserDefaultsManager.saveCurrentMeetingGroup(meetingGroup: self.currentMeetingGroup!)
    }
    
    func updateAfterSelectingEvent() {
        self.currentEvent?.debates = [Debate]()
    }
    
    func getSpeakingListNumberOfSections() -> Int {
        return speakingListNumberOfSections
    }
    
    // MARK: - VIP
    
    func fetchNames() {
        let response = TrackSpeakers.Speakers.Response(remainingList: remainingList, waitingList: waitingList, speakingList: speakingList,   currentDebate: currentDebate)
        presenter?.presentNames(response: response)
    }
    
    
    func moveNameRight(from tablePosition: TablePosition ) {
        
        switch tablePosition.tableIndex {
        case 0:
            let member = remainingList[0]!.remove(at: tablePosition.tableRow!)
            waitingList[0]!.append(member)
            var speakerMvt = SpeakerMovement()
            speakerMvt.sourceTablePosition = tablePosition
            speakerMvt.destinationTablePosition = TablePosition(tableIndex: 1, tableSection: 0, tableRow: waitingList[0]!.count - 1)
            speakerMvt.member = member
            undoStack.speakerMovements.append(speakerMvt)
        case 1:
            let member = waitingList[0]!.remove(at: tablePosition.tableRow!)
            speakingList[speakingListNumberOfSections - 1]!.append(member)
            var speakerMvt = SpeakerMovement()
            speakerMvt.sourceTablePosition = tablePosition
            speakerMvt.destinationTablePosition = TablePosition(tableIndex: 2, tableSection: speakingListNumberOfSections - 1, tableRow: speakingList[speakingListNumberOfSections - 1]!.count - 1)
            speakerMvt.member = member
            undoStack.speakerMovements.append(speakerMvt)
        default:
            print("TrackSpeakersInteractor: moveNameRight: case not covered")
        }
    }
    
    
    func moveNameLeft(from tablePosition: TablePosition ) {
        switch tablePosition.tableIndex {
        case 1:
            let member = waitingList[0]!.remove(at: tablePosition.tableRow!)
            let originalBaseList = currentMeetingGroup?.members
            let indexOfMemberInOriginalBaseList = originalBaseList?.firstIndex(where: {$0 == member})
            if remainingList.count <= indexOfMemberInOriginalBaseList! {
                remainingList[0]!.append(member)
            }
            else {
                var counter = 0
                for _ in remainingList {
                    if counter >= indexOfMemberInOriginalBaseList! {
                        remainingList[0]!.insert(member, at: counter)
                        break
                    }
                    counter += 1
                }
            }
            var speakerMvt = SpeakerMovement()
            speakerMvt.sourceTablePosition = tablePosition
            speakerMvt.destinationTablePosition = TablePosition(tableIndex: 0, tableSection: 0, tableRow: remainingList[0]!.count - 1)
            speakerMvt.member = member
            undoStack.speakerMovements.append(speakerMvt)
        case 2:
            let member = speakingList[speakingListNumberOfSections - 1]!.remove(at: tablePosition.tableRow!)
            waitingList[0]!.append(member)
            var speakerMvt = SpeakerMovement()
            speakerMvt.sourceTablePosition = tablePosition
            speakerMvt.destinationTablePosition = TablePosition(tableIndex: 1, tableSection: speakingListNumberOfSections - 1,tableRow: waitingList[0]!.count - 1)
            speakerMvt.member = member
            currentDebate!.debateSections![speakingListNumberOfSections - 1].speakerEvents?.removeAll(where: {$0.member == member })
            undoStack.speakerMovements.append(speakerMvt)
        default:
            print("TrackSpeakersInteractor: moveNameRight: case not covered")
        }
    }
    
    func copyNameToEnd(from tablePosition: TablePosition ) {
        let member = speakingList[tablePosition.tableSection!]![tablePosition.tableRow!]
        speakingList[speakingListNumberOfSections - 1]!.append(member)
    }
    
    func resetAllNames() {
        setUpListsAndDebate()
        for section in 1..<speakingListNumberOfSections {
            speakingList[section] = nil
        }
        speakingListNumberOfSections = 1
    }
    
    /*
     Store the main motion remaining and waiting lists for retrieval when amendment over.
     Place all members, except the mover of the amendment, back in remaining list.
     Initialise waiting list.
     Increase the section number count for the speaking list.
     Initialise the new speaking list section.
     */
    func beginAmendment() {
        mainMotionRemainingList = remainingList
        mainMotionWaitingList = waitingList
        var speakers = speakingList[speakingListNumberOfSections - 1]
        let finalSpeaker = speakers![speakers!.count - 1]
        let allMembers = currentMeetingGroup?.members
        let membersNotIncluding = allMembers!.filter {$0 != finalSpeaker }
        remainingList[0] = membersNotIncluding
        waitingList[0] = [Member]()
        speakingListNumberOfSections += 1
        speakingList[speakingListNumberOfSections - 1] = [Member]()
        let debateSection = DebateSection(sectionNumber: speakingListNumberOfSections - 1, sectionName: "Amendment debate", speakerEvents: [SpeakerEvent]())
        currentDebate?.debateSections?.append(debateSection)
    }

    func endAmendment() {
        remainingList = mainMotionRemainingList
        waitingList = mainMotionWaitingList
        speakingListNumberOfSections += 1
        speakingList[speakingListNumberOfSections - 1] = [Member]()
        let debateSection = DebateSection(sectionNumber: speakingListNumberOfSections - 1, sectionName: "Main debate", speakerEvents: [SpeakerEvent]())
        currentDebate?.debateSections?.append(debateSection)
    }
    
    func undoLastAction() {
        let speakerMvt = undoStack.speakerMovements.popLast()
        let member = speakerMvt?.member
        switch speakerMvt?.destinationTablePosition?.tableIndex {
        case 0:
            _ = remainingList[0]!.remove(at: (speakerMvt!.destinationTablePosition?.tableRow)!)
        case 1:
            _ = waitingList[0]!.remove(at: (speakerMvt!.destinationTablePosition?.tableRow)!)
        case 2:
            _ = speakingList[speakerMvt!.destinationTablePosition!.tableSection!]!.remove(at: (speakerMvt!.destinationTablePosition?.tableRow)!)
        default:
            break
        }
        switch speakerMvt?.sourceTablePosition?.tableIndex {
        case 0:
            remainingList[0]!.insert(member!, at: (speakerMvt?.sourceTablePosition?.tableRow)!)
        case 1:
            waitingList[0]!.insert(member!, at: (speakerMvt?.sourceTablePosition?.tableRow)!)
        case 2:
            speakingList[(speakerMvt?.sourceTablePosition?.tableSection)!]!.insert(member!, at: (speakerMvt?.sourceTablePosition?.tableRow)!)
        default:
            break
        }
    }
    
    
    func meetingGroupBelongsToCurrentEntity(meetingGroup: MeetingGroup) ->Bool {
        var result = false
        if let ent = currentEntity {
            if let groups = ent.meetingGroups {
                for mg in groups {
                    if mg == meetingGroup {
                        result = true
                    }
                }
            }
            return result
        }
        return false
    }
}
