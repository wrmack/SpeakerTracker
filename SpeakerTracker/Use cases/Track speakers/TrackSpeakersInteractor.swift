//
//  TrackSpeakersInteractor.swift
//  SpeakerTracker
//
//  Created by Warwick McNaughton on 14/09/18.
//  Copyright (c) 2018 Warwick McNaughton. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol TrackSpeakersBusinessLogic {
    // VIP
    func fetchNames()
    
    // Setup, updates and undo
    func setUpForNewDebate()
    func undoLastAction()
    func updateAfterSelectingMeetingGroup()
    func updateAfterSelectingEvent()
    
    // Entity and MeetingGroup
    func setCurrentEntity(entity: Entity)
    func getCurrentEntity()-> Entity?
    func setCurrentMeetingGroup(meetingGroup: MeetingGroup)
    func getCurrentMeetingGroup()->MeetingGroup?
    func meetingGroupBelongsToCurrentEntity(meetingGroup: MeetingGroup) ->Bool
    
    // Event, debates and speakers
    func setCurrentEvent(event: Event?)
    func getCurrentEvent()-> Event?
    func setCurrentSpeaker(section:Int, row: Int)
    func addCurrentSpeakerToDebateSection(startTime: Date, speakingTime: Int)
//    private func addCurrentDebateSectionToDebate()
    func addCurrentDebateToEvent(debateNote: String?)
    func getCurrentDebate()->Debate?
    
    // Move members between tables
    func moveNameRight(from tablePosition: TablePosition )
    func moveNameLeft(from tablePosition: TablePosition )
    func copyNameToEnd(from tablePosition: TablePosition )
    
    // Speaking list specific
    func beginAmendment()
    func endAmendment()
    func getSpeakingListNumberOfSections() -> Int
}

protocol TrackSpeakersDataStore {
    var currentEntity: Entity? {get set}
    var currentMeetingGroup: MeetingGroup? {get set}
    var currentEvent: Event? {get set}
    var currentDebate: Debate? {get set}
}


class TrackSpeakersInteractor: TrackSpeakersBusinessLogic, TrackSpeakersDataStore {
    
    internal var presenter: TrackSpeakersPresentationLogic?
    internal var currentEntity: Entity?
    internal var currentMeetingGroup: MeetingGroup?
    private var currentSpeaker: SpeakingListMember?
    private var currentIndexPath: IndexPath?
    internal var currentEvent: Event?
    internal var currentDebate: Debate?
    private var remainingList = [Int : [Member]]()
    private var waitingList = [Int : [Member]]()
    private var speakingList = [Int : [SpeakingListMember]]()
    private var mainMotionRemainingList = [Int : [Member]]()
    private var mainMotionWaitingList = [Int : [Member]]()
    private var speakingListNumberOfDebates = 1
    private var speakingListNumberOfSections = 1
    private var undoStack = UndoStack(speakerMovements: [SpeakerMovement]())

    
    // MARK: - VIP
    
    internal func fetchNames() {
        let response = TrackSpeakers.Speakers.Response(remainingList: remainingList, waitingList: waitingList, speakingList: speakingList)
        presenter?.presentNames(response: response)
    }
    
    
    // MARK: - Datastore -
    
    // MARK: Setups, updates and undo
    
    internal func setUpForNewDebate() {
        currentMeetingGroup!.members = [Member]()
        if (currentMeetingGroup!.memberIDs!.count) > 0 {
            for memberID in currentMeetingGroup!.memberIDs! {
                let mmbr = currentEntity!.members?.first(where: {$0.id == memberID})
                currentMeetingGroup?.members?.append(mmbr!)
            }
        }
        remainingList[0] = currentMeetingGroup!.members!
        waitingList[0] = [Member]()
        speakingList[0] = [SpeakingListMember]()
        if speakingListNumberOfSections > 0 {
            for section in 1..<speakingListNumberOfSections {
                speakingList[section] = nil
            }
        }
        speakingListNumberOfSections = 1
        let debateSection = DebateSection(sectionNumber: 0, sectionName: "Main debate", speakerEvents: [SpeakerEvent]())
        var debateNumber = 1
        if let event = currentEvent {
            debateNumber = (event.debates?.count)! + 1
        }
        currentDebate = Debate(debateNumber: debateNumber, note: nil, debateSections: [debateSection])
    }
    
    
    internal func updateAfterSelectingMeetingGroup() {
        currentMeetingGroup!.members = [Member]()
        if (currentMeetingGroup!.memberIDs!.count) > 0 {
            for memberID in currentMeetingGroup!.memberIDs! {
                let mmbr = currentEntity!.members?.first(where: {$0.id == memberID})
                currentMeetingGroup?.members?.append(mmbr!)
            }
        }
        remainingList[0] = currentMeetingGroup!.members!
        waitingList[0] = [Member]()
        speakingList[0] = [SpeakingListMember]()
        UserDefaultsManager.saveCurrentEntity(entity: self.currentEntity!)
        UserDefaultsManager.saveCurrentMeetingGroup(meetingGroup: self.currentMeetingGroup!)
    }
    
    internal func updateAfterSelectingEvent() {
        self.currentEvent?.debates = [Debate]()
    }
    

    
    internal func undoLastAction() {
        let speakerMvt = undoStack.speakerMovements.popLast()
        let member = speakerMvt?.member
        switch speakerMvt?.destinationTablePosition?.tableIndex {
        case 0:
            _ = remainingList[0]!.remove(at: (speakerMvt!.destinationTablePosition?.tableRow)!)
        case 1:
            _ = waitingList[0]!.remove(at: (speakerMvt!.destinationTablePosition?.tableRow)!)
        case 2:
            _ = speakingList[speakerMvt!.destinationTablePosition!.tableSection!]!.remove(at: (speakerMvt!.destinationTablePosition?.tableRow)!)
        default:
            break
        }
        switch speakerMvt?.sourceTablePosition?.tableIndex {
        case 0:
            remainingList[0]!.insert(member!, at: (speakerMvt?.sourceTablePosition?.tableRow)!)
        case 1:
            waitingList[0]!.insert(member!, at: (speakerMvt?.sourceTablePosition?.tableRow)!)
        case 2:
            let speakingListMbr = SpeakingListMember(member: member, elapsedMinutes: 0, elapsedSeconds: 0)
            speakingList[(speakerMvt?.sourceTablePosition?.tableSection)!]!.insert(speakingListMbr, at: (speakerMvt?.sourceTablePosition?.tableRow)!)
        default:
            break
        }
    }
    

    // MARK: - Entity and MeetingGroup
    
    internal func setCurrentEntity(entity: Entity) {
        currentEntity = entity
    }
    
    
    internal func getCurrentEntity()-> Entity? {
        return currentEntity
    }
 
    internal func setCurrentMeetingGroup(meetingGroup: MeetingGroup) {
        currentMeetingGroup = meetingGroup
        if currentMeetingGroup?.members == nil {
            currentMeetingGroup?.members = [Member]()
        }
        setUpForNewDebate()
    }
    
    internal func getCurrentMeetingGroup()->MeetingGroup? {
        return currentMeetingGroup
    }
    
    internal func meetingGroupBelongsToCurrentEntity(meetingGroup: MeetingGroup) ->Bool {
        var result = false
        if let ent = currentEntity {
            if let groups = ent.meetingGroups {
                for mg in groups {
                    if mg == meetingGroup {
                        result = true
                    }
                }
            }
            return result
        }
        return false
    }
    
    
    // MARK: - Event, debates and speakers
    
    internal func setCurrentEvent(event: Event?) {
        currentEvent = event
        currentEvent?.debates = [Debate]()
    }
    
    internal func getCurrentEvent()-> Event? {
        return currentEvent
    }
    
    internal func getCurrentDebate()->Debate? {
        return currentDebate
    }
    
    internal func setCurrentSpeaker(section:Int, row: Int) {
        speakingList[section]![row].speakingStatus = .isSpeaking
        currentSpeaker = speakingList[section]![row]
        currentIndexPath = IndexPath(row: row, section: section)
    }
    
    internal func addCurrentSpeakerToDebateSection(startTime: Date, speakingTime: Int) {
        let minutes = speakingTime / 60
        let seconds = speakingTime - (minutes * 60)
        speakingList[currentIndexPath!.section]![currentIndexPath!.row].speakingStatus = .hasSpoken
        speakingList[currentIndexPath!.section]![currentIndexPath!.row].elapsedMinutes = minutes
        speakingList[currentIndexPath!.section]![currentIndexPath!.row].elapsedSeconds = seconds
        let speakerEvent = SpeakerEvent(member: currentSpeaker?.member, elapsedMinutes: minutes, elapsedSeconds: seconds, startTime: startTime)
        currentDebate?.debateSections![speakingListNumberOfSections - 1].speakerEvents?.append(speakerEvent)
    }
    
    
    /*
     Called when Reset is pressed
     */
    internal func addCurrentDebateToEvent(debateNote: String?) {
        if currentDebate != nil {
            currentEvent?.debates?.append(currentDebate!)
        }
        currentDebate = nil
        if currentEvent != nil {
            saveCurrentEvent()
        }
    }
    
//    private func addCurrentDebateSectionToDebate() {
//
//    }
    
    private func saveCurrentEvent() {
        let fileManager = FileManager.default
        guard let docDirectory = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else {
            print("TrackSpeakersInteractor: saveCurrentEvent: error: Document directory not found")
            return
        }
        let eventURL = docDirectory.appendingPathComponent((currentEvent?.filename)! + ".evt")
        let eventDoc = EventDocument(fileURL: eventURL)
        eventDoc.open(completionHandler: { success in
            if !success {
                print("TrackSpeakersInteractor: saveCurrentEvent: error opening EventDocument")
            }
            else {
                eventDoc.event = self.currentEvent
                eventDoc.updateChangeCount(.done)
                eventDoc.close(completionHandler: { success in
                    if success == false {
                        print("TrackSpeakersInteractor: saveCurrentEvent: error closing EventDocument")
                    }
                })
            }
        })
    }
    
    // MARK: - Speaking list specific
    internal func getSpeakingListNumberOfSections() -> Int {
        return speakingListNumberOfSections
    }

    /*
     Store the main motion remaining and waiting lists for retrieval when amendment over.
     Place all members, except the mover of the amendment, back in remaining list.
     Initialise waiting list.
     Increase the section number count for the speaking list.
     Initialise the new speaking list section.
     */
    internal func beginAmendment() {
        mainMotionRemainingList = remainingList
        mainMotionWaitingList = waitingList
        var speakers = speakingList[speakingListNumberOfSections - 1]
        let finalSpeaker = speakers![speakers!.count - 1].member
        let allMembers = currentMeetingGroup?.members
        let membersNotIncluding = allMembers!.filter {$0 != finalSpeaker }
        remainingList[0] = membersNotIncluding
        waitingList[0] = [Member]()
        speakingListNumberOfSections += 1
        speakingList[speakingListNumberOfSections - 1] = [SpeakingListMember]()
        let debateSection = DebateSection(sectionNumber: speakingListNumberOfSections - 1, sectionName: "Amendment debate", speakerEvents: [SpeakerEvent]())
        currentDebate?.debateSections?.append(debateSection)
    }
    
    internal func endAmendment() {
        remainingList = mainMotionRemainingList
        waitingList = mainMotionWaitingList
        speakingListNumberOfSections += 1
        speakingList[speakingListNumberOfSections - 1] = [SpeakingListMember]()
        let debateSection = DebateSection(sectionNumber: speakingListNumberOfSections - 1, sectionName: "Main debate", speakerEvents: [SpeakerEvent]())
        currentDebate?.debateSections?.append(debateSection)
    }
    

    // MARK: - Moving members between tables
    
    internal func moveNameRight(from tablePosition: TablePosition ) {
        
        switch tablePosition.tableIndex {
        case 0:
            let member = remainingList[0]!.remove(at: tablePosition.tableRow!)
            waitingList[0]!.append(member)
            var speakerMvt = SpeakerMovement()
            speakerMvt.sourceTablePosition = tablePosition
            speakerMvt.destinationTablePosition = TablePosition(tableIndex: 1, tableSection: 0, tableRow: waitingList[0]!.count - 1)
            speakerMvt.member = member
            undoStack.speakerMovements.append(speakerMvt)
        case 1:
            let member = waitingList[0]!.remove(at: tablePosition.tableRow!)
            let spkgListMbr = SpeakingListMember(member: member, elapsedMinutes: 0, elapsedSeconds: 0)
            speakingList[speakingListNumberOfSections - 1]!.append(spkgListMbr)
            var speakerMvt = SpeakerMovement()
            speakerMvt.sourceTablePosition = tablePosition
            speakerMvt.destinationTablePosition = TablePosition(tableIndex: 2, tableSection: speakingListNumberOfSections - 1, tableRow: speakingList[speakingListNumberOfSections - 1]!.count - 1)
            speakerMvt.member = member
            undoStack.speakerMovements.append(speakerMvt)
        default:
            print("TrackSpeakersInteractor: moveNameRight: case not covered")
        }
    }
    
    
    internal func moveNameLeft(from tablePosition: TablePosition ) {
        switch tablePosition.tableIndex {
        case 1:
            let member = waitingList[0]!.remove(at: tablePosition.tableRow!)
            let originalBaseList = currentMeetingGroup?.members
            let indexOfMemberInOriginalBaseList = originalBaseList?.firstIndex(where: {$0 == member})
            if remainingList.count <= indexOfMemberInOriginalBaseList! {
                remainingList[0]!.append(member)
            }
            else {
                var counter = 0
                for _ in remainingList {
                    if counter >= indexOfMemberInOriginalBaseList! {
                        remainingList[0]!.insert(member, at: counter)
                        break
                    }
                    counter += 1
                }
            }
            var speakerMvt = SpeakerMovement()
            speakerMvt.sourceTablePosition = tablePosition
            speakerMvt.destinationTablePosition = TablePosition(tableIndex: 0, tableSection: 0, tableRow: remainingList[0]!.count - 1)
            speakerMvt.member = member
            undoStack.speakerMovements.append(speakerMvt)
        case 2:
            let spkgListMbr = speakingList[speakingListNumberOfSections - 1]!.remove(at: tablePosition.tableRow!)
            waitingList[0]!.append(spkgListMbr.member!)
            var speakerMvt = SpeakerMovement()
            speakerMvt.sourceTablePosition = tablePosition
            speakerMvt.destinationTablePosition = TablePosition(tableIndex: 1, tableSection: speakingListNumberOfSections - 1,tableRow: waitingList[0]!.count - 1)
            speakerMvt.member = spkgListMbr.member!
            currentDebate!.debateSections![speakingListNumberOfSections - 1].speakerEvents?.removeAll(where: {$0.member == spkgListMbr.member! })
            undoStack.speakerMovements.append(speakerMvt)
        default:
            print("TrackSpeakersInteractor: moveNameRight: case not covered")
        }
    }
    
    internal func copyNameToEnd(from tablePosition: TablePosition ) {
        let member = speakingList[tablePosition.tableSection!]![tablePosition.tableRow!]
        speakingList[speakingListNumberOfSections - 1]!.append(member)
    }

    

 
}
