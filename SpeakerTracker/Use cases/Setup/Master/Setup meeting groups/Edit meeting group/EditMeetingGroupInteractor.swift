//
//  EditMeetingGroupInteractor.swift
//  SpeakerTracker
//
//  Created by Warwick McNaughton on 14/09/18.
//  Copyright (c) 2018 Warwick McNaughton. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol EditMeetingGroupBusinessLogic {
    func getEntity() -> Entity?
    func getMeetingGroup() -> MeetingGroup?
    func saveMeetingGroupToEntity(meetingGroup: MeetingGroup, callback: @escaping ()->())
    func addMeetingGroupToBeDeletedToDataStore(meetingGroup: MeetingGroup)
    func fetchMembers(request: EditMeetingGroup.MeetingGroup.Request)
}

protocol EditMeetingGroupDataStore {
    var entity: Entity? {get set}
    var meetingGroup: MeetingGroup? {get set}
    var memberIDs: [UUID]? {get set}
}


class EditMeetingGroupInteractor: EditMeetingGroupBusinessLogic, EditMeetingGroupDataStore {
    var presenter: EditMeetingGroupPresentationLogic?
    var entity: Entity?
    var meetingGroup: MeetingGroup?
    var memberIDs: [UUID]?
    
    
    // MARK: - VIP
    
    func fetchMembers(request: EditMeetingGroup.MeetingGroup.Request) {
        meetingGroup?.memberIDs = memberIDs
        var meetingGroupMembers = [Member]()
        for memberID in (meetingGroup?.memberIDs)! {
            let mmbr = entity?.members?.first(where: {$0.id == memberID })
            meetingGroupMembers.append(mmbr!)
        }
        let response = EditMeetingGroup.MeetingGroup.Response(members: meetingGroupMembers)
        self.presenter?.presentMembers(response: response)
    }
    
    
    
    // MARK: - Datastore
    
    /*
     The meeting group from the editing form is passed in as a parameter.
     The members property was updated through data-passing after members were selected so members need to be added to the meeting group.
     
     */
    func saveMeetingGroupToEntity(meetingGroup: MeetingGroup, callback: @escaping ()->()) {
        if entity!.meetingGroups == nil {
            entity!.meetingGroups = [MeetingGroup]()
        }
        self.meetingGroup?.name = meetingGroup.name
        // New memberIDs from data-passing after selecting members, otherwise meetingGroup memberIDs don't change
        if memberIDs != nil {
            self.meetingGroup?.memberIDs = memberIDs
        }
        if let idx = entity!.meetingGroups?.firstIndex(where: {$0.id == meetingGroup.id}) {
            entity?.meetingGroups![idx] = self.meetingGroup!
        }
        let savedEntity = UserDefaultsManager.getCurrentEntity()
        if savedEntity == self.entity {
            UserDefaultsManager.saveCurrentEntity(entity: self.entity!)
        }
        guard let docDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            print("EditMeetingGroupInteractor: saveMeetingGroupToEntity: error: Document directory not found")
            return
        }
        let docFileURL = docDirectory.appendingPathComponent((entity?.id?.uuidString)! + ".ent")
        let entityDoc = EntityDocument(fileURL: docFileURL)
        entityDoc.open(completionHandler: { success in
            if !success {
                print("EditMeetingGroupInteractor: saveMeetingGroupToEntity: error opening EntityDocument")
            }
            else {
                
                if entityDoc.entity!.meetingGroups == nil {
                    entityDoc.entity!.meetingGroups = [MeetingGroup]()
                }
                if let idx = entityDoc.entity!.meetingGroups?.firstIndex(where: {$0.id == meetingGroup.id}) {
                    entityDoc.entity?.meetingGroups![idx] = self.meetingGroup!
                }
                entityDoc.updateChangeCount(.done)
                entityDoc.close(completionHandler: { success in
                    print(entityDoc)
                    callback()
                })
            }
        })
    }
    
    
    func getMeetingGroup() -> MeetingGroup? {
        return self.meetingGroup
    }
    
    func getEntity() -> Entity? {
        return self.entity
    }
    
    func addMeetingGroupToBeDeletedToDataStore(meetingGroup: MeetingGroup) {
        self.meetingGroup = meetingGroup
    }
}

