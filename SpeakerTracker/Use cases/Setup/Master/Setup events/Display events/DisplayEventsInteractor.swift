//
//  DisplayEventsInteractor.swift
//  SpeakerTracker
//
//  Created by Warwick McNaughton on 2/09/18.
//  Copyright (c) 2018 Warwick McNaughton. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol DisplayEventsBusinessLogic {
    func fetchEvents(request: DisplayEvents.Events.Request)
    func getCurrentEventIndex()->Int?
    func setCurrentEvent(index: Int)
    func setMeetingGroup(meetingGroup: MeetingGroup)
    func setEntity(entity: Entity)
    func getCurrentEntity() -> Entity
    func resetData()
}

protocol DisplayEventsDataStore {
    var event: Event? {get set}
    var entity: Entity? {get set}
    var meetingGroup: MeetingGroup? {get set}
}


class DisplayEventsInteractor: DisplayEventsBusinessLogic, DisplayEventsDataStore {
    var presenter: DisplayEventsPresentationLogic?
    var event: Event?
    var events: [Event]?
    var entity: Entity?
    var meetingGroup: MeetingGroup?

    
    // MARK: - VIP
    
    /*
     Initialises 'events' for storing events for the given entity and meeting group.
     Gets the urls for all event docs.
     Opens each event doc and gets its event.
     If the event's entity and meeting group match what we want, the event is added to 'events' and the event doc is closed.
     */
    func fetchEvents(request: DisplayEvents.Events.Request) {
        events = [Event]()
        let fileManager = FileManager.default
        guard let docDirectory = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else {
            print("DisplayEventsInteractor: fetchEvents: error: Document directory not found")
            return
        }
        do {
            var eventUrls = [URL]()
            let fileURLs = try fileManager.contentsOfDirectory(at: docDirectory, includingPropertiesForKeys: nil)
            for url in fileURLs {
                if url.pathExtension == "evt" {
                    eventUrls.append(url)
                }
            }
            
            if eventUrls.count == 0 {
                self.event = nil
                let response = DisplayEvents.Events.Response(events: self.events)
                self.presenter?.presentEvents(response: response)
            }
            else {
                var count = 0
                for eventUrl in eventUrls {
                    let eventDoc = EventDocument(fileURL: eventUrl)
                    eventDoc.open(completionHandler: { success in
                        if !success {
                            print("DisplayEventsInteractor: fetchEvents: error opening EventDocument")
                            return
                        }
                        else {
                            guard var event = eventDoc.event else {
                                print("DisplayEventsPopUpInteractor: fetchEvents: event is nil")
                                return
                            }
                            if event.entity == self.entity && event.meetingGroup == self.meetingGroup {
                                if event.meetingGroup?.memberIDs == nil {
                                    event.meetingGroup?.memberIDs = [UUID]()
                                }
                                if event.meetingGroup?.memberIDs!.count != self.meetingGroup!.memberIDs!.count {
                                    event.meetingGroup!.memberIDs = self.meetingGroup?.memberIDs
                                    eventDoc.event = event
                                    eventDoc.updateChangeCount(.done)
                                }
                                self.events!.append(event)
                            }
                            
                            eventDoc.close(completionHandler: {success in

                                count += 1
                                if count == eventUrls.count {
                                    let response = DisplayEvents.Events.Response(events: self.events)
                                    self.presenter?.presentEvents(response: response)
                                }
                            })
                        }
                    })
                }
            }
            
        }
        catch {
            print("Error while enumerating files \(docDirectory.path): \(error.localizedDescription)")
        }
        
    }
    
    
    // MARK: - Datastore
    
    func getCurrentEventIndex()->Int? {
        if event != nil {
            return events!.firstIndex(where: { $0.id == event!.id}) 
        }
        return 0
    }
    
    
    func setCurrentEvent(index: Int) {
        if (events?.count)! > 0 {
            event = events![index]
        }
        else {
            event = nil
        }
    }
    
    
    func setMeetingGroup(meetingGroup: MeetingGroup) {
        self.meetingGroup = meetingGroup
    }
    
    func setEntity(entity: Entity) {
        self.entity = entity
        self.events = nil
        self.event = nil
        self.meetingGroup = nil
    }
    
    
    func getCurrentEntity() -> Entity {
        return self.entity!
    }
    
    
    func resetData() {
        self.entity = nil
        self.event = nil
        self.events = nil
        self.meetingGroup = nil
    }
}
